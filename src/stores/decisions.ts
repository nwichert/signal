import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import {
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  onSnapshot,
  serverTimestamp,
  query,
  orderBy,
} from 'firebase/firestore'
import { db } from '@/firebase/config'
import type { Decision, DecisionOption, DecisionStatus, DecisionCategory, ImplementationStatus } from '@/types'
import { useAuthStore } from './auth'

export const useDecisionsStore = defineStore('decisions', () => {
  const decisions = ref<Decision[]>([])
  const loading = ref(true)
  const saving = ref(false)
  const error = ref<string | null>(null)

  let unsubscribe: (() => void) | null = null

  const proposedDecisions = computed(() =>
    decisions.value.filter((d) => d.status === 'proposed')
  )

  const decidedDecisions = computed(() =>
    decisions.value.filter((d) => d.status === 'decided')
  )

  const revisitedDecisions = computed(() =>
    decisions.value.filter((d) => d.status === 'revisited')
  )

  // Get decisions by category
  function getDecisionsByCategory(category: DecisionCategory) {
    return decisions.value.filter((d) => d.category === category)
  }

  function subscribe() {
    if (unsubscribe) return

    loading.value = true

    const decisionsQuery = query(
      collection(db, 'decisions'),
      orderBy('createdAt', 'desc')
    )

    unsubscribe = onSnapshot(
      decisionsQuery,
      (snapshot) => {
        decisions.value = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        })) as Decision[]
        loading.value = false
      },
      (err) => {
        console.error('Decisions subscription error:', err)
        error.value = err.message
        loading.value = false
      }
    )
  }

  function unsubscribeFromDecisions() {
    if (unsubscribe) {
      unsubscribe()
      unsubscribe = null
    }
  }

  async function addDecision(data: {
    title: string
    context: string
    category: DecisionCategory
    owner: string
    options: Omit<DecisionOption, 'id'>[]
    relatedHypothesisIds?: string[]
    focusAreaId?: string
    autoGenerated?: boolean
    sourceHypothesisId?: string
  }) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    saving.value = true
    error.value = null

    try {
      // Generate IDs for options
      const optionsWithIds = data.options.map((opt, index) => ({
        ...opt,
        id: `opt-${Date.now()}-${index}`,
      }))

      const decisionData: Record<string, unknown> = {
        title: data.title,
        context: data.context,
        category: data.category,
        owner: data.owner,
        status: 'proposed' as DecisionStatus,
        options: optionsWithIds,
        rationale: '',
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        createdBy: authStore.user?.id,
      }

      // Add optional fields only if they have values
      if (data.relatedHypothesisIds && data.relatedHypothesisIds.length > 0) {
        decisionData.relatedHypothesisIds = data.relatedHypothesisIds
      }
      if (data.focusAreaId) {
        decisionData.focusAreaId = data.focusAreaId
      }
      if (data.autoGenerated) {
        decisionData.autoGenerated = true
      }
      if (data.sourceHypothesisId) {
        decisionData.sourceHypothesisId = data.sourceHypothesisId
      }

      await addDoc(collection(db, 'decisions'), decisionData)
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to add decision'
      error.value = message
      throw e
    } finally {
      saving.value = false
    }
  }

  async function updateDecision(
    id: string,
    data: Partial<Pick<Decision, 'title' | 'context' | 'category' | 'owner' | 'rationale' | 'outcome' | 'relatedHypothesisIds' | 'focusAreaId'>>
  ) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        ...data,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to update decision'
      error.value = message
      throw e
    }
  }

  // Link hypotheses to a decision (evidence linking)
  async function linkHypothesesToDecision(decisionId: string, hypothesisIds: string[]) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', decisionId)
      await updateDoc(docRef, {
        relatedHypothesisIds: hypothesisIds,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to link hypotheses'
      error.value = message
      throw e
    }
  }

  // Get decisions linked to a specific hypothesis
  function getDecisionsForHypothesis(hypothesisId: string) {
    return decisions.value.filter(d =>
      d.relatedHypothesisIds?.includes(hypothesisId) ||
      d.sourceHypothesisId === hypothesisId
    )
  }

  // Get auto-generated decisions
  const autoGeneratedDecisions = computed(() =>
    decisions.value.filter(d => d.autoGenerated)
  )

  // Implementation status computed properties
  const decisionsNotStarted = computed(() =>
    decisions.value.filter(d => d.status === 'decided' && (!d.implementationStatus || d.implementationStatus === 'not-started'))
  )

  const decisionsInProgress = computed(() =>
    decisions.value.filter(d => d.implementationStatus === 'in-progress')
  )

  const decisionsCompleted = computed(() =>
    decisions.value.filter(d => d.implementationStatus === 'completed')
  )

  const decisionsBlocked = computed(() =>
    decisions.value.filter(d => d.implementationStatus === 'blocked')
  )

  // Decisions needing retrospective (completed but no lessons learned)
  const decisionsNeedingRetrospective = computed(() =>
    decisions.value.filter(d =>
      d.implementationStatus === 'completed' &&
      !d.lessonsLearned
    )
  )

  // Get decision by ID
  function getDecisionById(id: string): Decision | undefined {
    return decisions.value.find(d => d.id === id)
  }

  // Get decisions by focus area
  function getDecisionsByFocusArea(focusAreaId: string): Decision[] {
    return decisions.value.filter(d => d.focusAreaId === focusAreaId)
  }

  async function makeDecision(id: string, selectedOptionId: string, rationale: string) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const decision = decisions.value.find((d) => d.id === id)
      if (!decision) throw new Error('Decision not found')

      // Update options to mark selected one
      const updatedOptions = decision.options.map((opt) => ({
        ...opt,
        selected: opt.id === selectedOptionId,
      }))

      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        status: 'decided',
        options: updatedOptions,
        rationale,
        decidedAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to make decision'
      error.value = message
      throw e
    }
  }

  async function revisitDecision(id: string) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        status: 'revisited',
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to revisit decision'
      error.value = message
      throw e
    }
  }

  async function reopenDecision(id: string) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        status: 'proposed',
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to reopen decision'
      error.value = message
      throw e
    }
  }

  async function addOption(decisionId: string, option: Omit<DecisionOption, 'id'>) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const decision = decisions.value.find((d) => d.id === decisionId)
      if (!decision) throw new Error('Decision not found')

      const newOption: DecisionOption = {
        ...option,
        id: `opt-${Date.now()}`,
      }

      const docRef = doc(db, 'decisions', decisionId)
      await updateDoc(docRef, {
        options: [...decision.options, newOption],
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to add option'
      error.value = message
      throw e
    }
  }

  async function updateOption(
    decisionId: string,
    optionId: string,
    data: Partial<Omit<DecisionOption, 'id'>>
  ) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const decision = decisions.value.find((d) => d.id === decisionId)
      if (!decision) throw new Error('Decision not found')

      const updatedOptions = decision.options.map((opt) =>
        opt.id === optionId ? { ...opt, ...data } : opt
      )

      const docRef = doc(db, 'decisions', decisionId)
      await updateDoc(docRef, {
        options: updatedOptions,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to update option'
      error.value = message
      throw e
    }
  }

  async function deleteOption(decisionId: string, optionId: string) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const decision = decisions.value.find((d) => d.id === decisionId)
      if (!decision) throw new Error('Decision not found')

      const updatedOptions = decision.options.filter((opt) => opt.id !== optionId)

      const docRef = doc(db, 'decisions', decisionId)
      await updateDoc(docRef, {
        options: updatedOptions,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to delete option'
      error.value = message
      throw e
    }
  }

  async function deleteDecision(id: string) {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      await deleteDoc(doc(db, 'decisions', id))
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to delete decision'
      error.value = message
      throw e
    }
  }

  // Implementation tracking functions
  async function updateImplementationStatus(
    id: string,
    status: ImplementationStatus
  ): Promise<void> {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const updateData: Record<string, unknown> = {
        implementationStatus: status,
        updatedAt: serverTimestamp(),
      }

      // Set start date when moving to in-progress
      if (status === 'in-progress') {
        const decision = decisions.value.find(d => d.id === id)
        if (decision && !decision.implementationStartDate) {
          updateData.implementationStartDate = serverTimestamp()
        }
      }

      // Set completion date when moving to completed
      if (status === 'completed') {
        updateData.implementationCompletedDate = serverTimestamp()
      }

      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, updateData)
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to update implementation status'
      error.value = message
      throw e
    }
  }

  // Record actual outcome after implementation
  async function recordActualOutcome(
    id: string,
    actualOutcome: string
  ): Promise<void> {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        actualOutcome,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to record outcome'
      error.value = message
      throw e
    }
  }

  // Record lessons learned and retrospective
  async function recordLessonsLearned(
    id: string,
    data: {
      lessonsLearned: string
      wouldDecideSameAgain?: boolean
    }
  ): Promise<void> {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        lessonsLearned: data.lessonsLearned,
        wouldDecideSameAgain: data.wouldDecideSameAgain,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to record lessons learned'
      error.value = message
      throw e
    }
  }

  // Link changelog entries (shipped features) to a decision
  async function linkChangelogEntries(
    id: string,
    changelogIds: string[]
  ): Promise<void> {
    const authStore = useAuthStore()
    if (!authStore.canEdit) {
      throw new Error('Not authorized')
    }

    try {
      const docRef = doc(db, 'decisions', id)
      await updateDoc(docRef, {
        changelogIds,
        updatedAt: serverTimestamp(),
      })
    } catch (e) {
      const message = e instanceof Error ? e.message : 'Failed to link changelog entries'
      error.value = message
      throw e
    }
  }

  // Get implementation status badge class
  function getImplementationStatusBadgeClass(status: ImplementationStatus | undefined): string {
    switch (status) {
      case 'not-started':
        return 'badge-gray'
      case 'in-progress':
        return 'badge-blue'
      case 'completed':
        return 'badge-green'
      case 'blocked':
        return 'badge-red'
      case 'abandoned':
        return 'badge-gray'
      default:
        return 'badge-gray'
    }
  }

  // Get category badge class
  function getCategoryBadgeClass(category: DecisionCategory): string {
    switch (category) {
      case 'product':
        return 'badge-blue'
      case 'technical':
        return 'badge-purple'
      case 'process':
        return 'badge-yellow'
      case 'strategy':
        return 'badge-green'
      default:
        return 'badge-gray'
    }
  }

  // Get status badge class
  function getStatusBadgeClass(status: DecisionStatus): string {
    switch (status) {
      case 'proposed':
        return 'badge-yellow'
      case 'decided':
        return 'badge-green'
      case 'revisited':
        return 'badge-blue'
      default:
        return 'badge-gray'
    }
  }

  return {
    decisions,
    proposedDecisions,
    decidedDecisions,
    revisitedDecisions,
    autoGeneratedDecisions,
    // Implementation tracking computed
    decisionsNotStarted,
    decisionsInProgress,
    decisionsCompleted,
    decisionsBlocked,
    decisionsNeedingRetrospective,
    loading,
    saving,
    error,
    subscribe,
    unsubscribe: unsubscribeFromDecisions,
    // Query functions
    getDecisionsByCategory,
    getDecisionsForHypothesis,
    getDecisionById,
    getDecisionsByFocusArea,
    // Badge utilities
    getCategoryBadgeClass,
    getStatusBadgeClass,
    getImplementationStatusBadgeClass,
    // CRUD
    addDecision,
    updateDecision,
    linkHypothesesToDecision,
    makeDecision,
    revisitDecision,
    reopenDecision,
    addOption,
    updateOption,
    deleteOption,
    deleteDecision,
    // Implementation tracking
    updateImplementationStatus,
    recordActualOutcome,
    recordLessonsLearned,
    linkChangelogEntries,
  }
})
